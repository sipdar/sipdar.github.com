---
layout: post
title: 自动增强图片效果
---

**Core Image**的自动强图片效果，会分析图像的直方图，图像属性，脸部区域，然后通过一组滤镜来改善图片效果。

##自动增强滤镜
下面这些滤镜可以修正照片中的大部分问题：



Filter | Purpose
------------ | -------------  
CIRedEyeCorrection | Repairs red/amber/white eye due to camera flash
CIFaceBalance | Adjusts the color of a face to give pleasing skin tones
CIVibrance | Increases the saturation of an image without distorting the skin tones
CIToneCurve | Adjusts image contrastCIHighlightShadowAdjust | Adjusts shadow details
自动增强API仅有2个方法： **autoAdjustmentFilters **和** autoAdjustmentFiltersWithOptions:**. 多数情况下，我们使用带参数的方法。
* 图像的方向 :对于**CIRedEyeCorrection**和**CIFaceBalance**滤镜，提供图像方向可以使**Core Image** 更精确的定位到脸的位置。
* 是否应用红眼校正把**kCIImageAutoAdjustEnhance**设置为false）
* 是否使用红眼校正以外的全部其他滤镜。（把**kCIImageAutoAdjustRedEye**设置为false）

通过**autoAdjustmentFiltersWithOptions**我们会得到一个包含图像增强的所有的滤镜的数组。依次调用它们处理图像。

	CIContext *context = [CIContext contextWithOptions:nil];
	UIImage *baby = [UIImage imageNamed:@"1.jpg"];
	CIImage *myImage = [CIImage imageWithCGImage:baby.CGImage];
	NSArray *adjustments = [myImage autoAdjustmentFilters];	for (CIFilter *filter in adjustments) {		[filter setValue:myImage forKey:kCIInputImageKey];		myImage = filter.outputImage;	}
	
![image](http://sipdar.github.io/image/2014/03/28/5.png)

左图就是自动增强之后的效果。

## 负片滤镜

	CIFilter *filter = [CIFilter filterWithName:@"CIColorMatrix" keysAndValues:						kCIInputImageKey, myImage,						@"inputRVector", [CIVector vectorWithX: -1 Y:0 Z:0],						@"inputGVector", [CIVector vectorWithX:0 Y:-1 Z:0 ],						@"inputBVector", [CIVector vectorWithX: 0 Y:0 Z:-1],						@"inputBiasVector", [CIVector vectorWithX:1 Y:1 Z:1],nil];

![image](http://sipdar.github.io/image/2014/03/28/1.png)

##扣图滤镜
我们可以删除一幅图像中指定的颜色，然后填充一个背景。类似好莱坞大片的背景合成。
![image](http://sipdar.github.io/image/2014/03/28/2.png)

要实现上面图片的效果有下面几个步骤

* 首先我们要从图像中删除我们要删掉的颜色，通过创建一个颜色矩阵，将要删除的颜色变换成透明色。
* 用**CICOlorCube** 滤镜删除图像中通过矩阵变换过的颜色。
* 最后用 **CISourceOverCompositing** 合成图片。

###创建一个 color Cube Map
一个color cube是一个3D颜色查找表（lookup table）。Core Image 滤镜 CIColorCube 使用色值作为输入，并应用一个查找表到这些色值。
**CIColorCube**从图像中删除所有的绿色。就是要把图中的把绿色的**alpha**值设置为0.0（透明）。

“绿色”包括一定范围内的颜色。最直接的处理方式是把图像的色值从RGBA转为HSV。HSV把颜色描述在圆柱坐标系内的点。

![image](http://sipdar.github.io/image/2014/03/28/4.png)

要删除绿色，你需要定义围绕中心点的最小和最大的角度。之后，对于任何的绿色，将其alpha值设置为0.0。纯绿的相对角度是120º。最小值和最大值要以这个值为中心。
![image](http://sipdar.github.io/image/2014/03/28/3.png)

Cube map数据必须预乘alpha，所以创建cube map的最后一步是把RGB值乘以你刚刚计算出的alpha值（如果是绿色，就是0，如果不是就是1.0） 下面是例子代码。 

	CIContext *context = [CIContext contextWithOptions:nil];
	UIImage *baby = [UIImage imageNamed:@"2.jpg"];
	CIImage *myImage = [CIImage imageWithCGImage:baby.CGImage];
	// Allocate memory
	const unsigned int size = 64;
	float *cubeData = (float *)malloc (size * size * size * sizeof (float) * 4);
	float rgb[3], hsv[3], *c = cubeData;
	
	// Populate cube with a simple gradient going from 0 to 1
	for (int z = 0; z < size; z++){
		rgb[2] = ((double)z)/(size-1); // Blue value
		for (int y = 0; y < size; y++){
			rgb[1] = ((double)y)/(size-1); // Green value
			for (int x = 0; x < size; x ++){
				rgb[0] = ((double)x)/(size-1); // Red value
				// Convert RGB to HSV
				// You can find publicly available rgbToHSV functions on the Internet
				RGBtoHSV(rgb[0],rgb[1],rgb[2], &hsv[0],&hsv[1],&hsv[2]);

				float alpha = (hsv[0] > 80 && hsv[0] < 130) ? 0.0f:1.0f;
				// Calculate premultiplied alpha values for the cube
				c[0] = rgb[0] * alpha;
				c[1] = rgb[1] * alpha;
				c[2] = rgb[2] * alpha;
				c[3] = alpha;
				c += 4;
			}
		}
	}
	// Create memory with the cube data
	NSData *data = [NSData dataWithBytesNoCopy:cubeData length:(size * size * size * sizeof (float) * 4) freeWhenDone:YES];
	CIFilter *colorCube = [CIFilter filterWithName:@"CIColorCube"];
	[colorCube setValue:@(size) forKey:@"inputCubeDimension"];
	[colorCube setValue:myImage forKey:@"inputImage"];
	[colorCube setValue:data forKey:@"inputCubeData"];
	myImage = colorCube.outputImage;

	void RGBtoHSV( float r, float g, float b, float *h, float *s, float *v ){
		float min, max, delta;
		min = MIN( r, MIN(g, b) );
		max = MAX( r, MAX(g, b) );
		*v = max;				// v
		delta = max - min;
		if( max != 0 )
			*s = delta / max;		// s
		else {
		// r = g = b = 0		// s = 0, v is undefined
			*s = 0;
			*h = -1;
			return;
		}
		if( r == max )
			*h = ( g - b ) / delta;		// between yellow & magenta
		else if( g == max )
			*h = 2 + ( b - r ) / delta;	// between cyan & yellow
		else
			*h = 4 + ( r - g ) / delta;	// between magenta & cyan
		*h *= 60;				// degrees
		if( *h < 0 )
			*h += 360;
	}

![image](http://sipdar.github.io/image/2014/03/28/6.png)

我们可以根据 **HSV**角度试试删除黄色

		float alpha = (hsv[0] > 30 && hsv[0] < 55) ? 0.0f:1.0f;

![image](http://sipdar.github.io/image/2014/03/28/7.png)	

删除指定的颜色后，我们可以填充一个背景图片。

![image](http://sipdar.github.io/image/2014/03/28/9.png)	

	UIImage *image2 = [UIImage imageNamed:@"5.png"];
	CIImage *backgroundCIImage = [CIImage imageWithCGImage:image2.CGImage];
	myImage = [[CIFilter filterWithName:@"CISourceOverCompositing" keysAndValues:kCIInputImageKey,myImage,kCIInputBackgroundImageKey,backgroundCIImage,nil] valueForKey:kCIOutputImageKey];
	CGRect extent = [myImage extent];
	CGImageRef cgImage = [context createCGImage:myImage fromRect:extent];
					
![image](http://sipdar.github.io/image/2014/03/28/8.png)						
					