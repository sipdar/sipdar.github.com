<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Sunny &middot; A iOS tech blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0c">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Sunny
        </a>
      </h1>
      <p class="lead">This is my personal blog Welcome ！<a href="https://twitter.com/sipdar" target="_blank">@sunny</a>.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item active" href="/">Home</a>
      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive/">Archives</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
      
<!--       <a class="sidebar-nav-item" href="https://github.com/sipdar/archive/v2.1.0.zip">Download</a> -->
      <a class="sidebar-nav-item" href="https://github.com/sipdar">GitHub project</a>
      <a class="sidebar-nav-item" href="mailto:sipdar@163.com">Email</a>
<!--       <span class="sidebar-nav-item">Currently v2.1.0</span> -->

    </nav>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/01/24/Swift%20%E9%97%AD%E5%8C%85/">
        Swift
      </a>
    </h1>

    <span class="post-date">24 Jan 2015</span>

     <h2>函数 ()-&gt;()</h2>

<p><strong>Swift</strong> 中的闭包和 <strong>Objective-C</strong> 中的 <strong>block</strong> 类似，闭包是功能性自包含模块，可以在代码中被传递和使用。 在 <strong>Swift</strong> 中  函数只是闭包的一种特殊形式。</p>

<p>1.全局函数是一个有名字但不会捕获任何值的闭包
2.内嵌函数是一个有名字可以捕获到所在的函数域内值的闭包
3.闭包表达式是一个没有名字的可以捕获上下文中的变量或者常量的闭包</p>

<h3>定义函数</h3>

<p>我们在 <strong>Swift</strong> 中使用 <strong>func</strong> 关键字来定义函数，函数可以没有参数和返回值，也可以有一个或者多个参数和返回值。在<strong>Swift</strong>中多个参数的返回值叫做元组(<strong>tuples</strong>)</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="n">foo</span><span class="p">(</span><span class="nl">firstname</span><span class="p">:</span><span class="n">String</span> <span class="p">,</span><span class="nl">lastname</span><span class="p">:</span><span class="n">String</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="nl">fullname</span><span class="p">:</span><span class="n">String</span><span class="p">)</span>
   <span class="k">return</span><span class="p">(</span><span class="s">&quot;(firstname) (lastname)&quot;</span><span class="p">)</span>
 <span class="p">}</span></code></pre></div>

<h3>函数调用</h3>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="n">fullname</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="s">&quot;zhao”,”sunny”)</span></code></pre></div>

<h3>函数类型</h3>

<p>每一个函数都有它的类型，函数的类型由函数本身的参数类型和返回值类型来决定的。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="n">sum</span><span class="p">(</span><span class="nl">x</span><span class="p">:</span><span class="n">Int</span><span class="p">,</span><span class="nl">y</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nl">result</span><span class="p">:</span><span class="n">Int</span><span class="p">)</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">Y</span></code></pre></div>

<p>上面这个函数的函数类型就是</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">(</span><span class="n">Int</span><span class="p">,</span><span class="n">Int</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">Int</span><span class="p">)</span></code></pre></div>

<p>函数类型在构建函数的时候当成参数类型或者返回值类型来使用。</p>

<h3>返回函数类型</h3>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">func</span> <span class="n">foo</span><span class="p">()</span><span class="o">-&gt;</span><span class="p">((</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="p">)</span>
   <span class="n">func</span> <span class="n">bar</span><span class="p">(</span><span class="nl">firstname</span><span class="p">:</span><span class="n">String</span><span class="p">,</span><span class="nl">lastname</span><span class="p">:</span><span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span><span class="p">(</span><span class="nl">fullname</span><span class="p">:</span><span class="n">String</span><span class="p">)</span>
  <span class="k">return</span><span class="p">(</span><span class="s">&quot;(firstname) (lastname)&quot;</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">bar</span>
 <span class="p">}</span>
 <span class="n">let</span> <span class="n">namecombination</span> <span class="err">＝</span> <span class="n">foo</span><span class="p">()</span>
 <span class="n">namecombination</span><span class="p">(</span><span class="s">&quot;wang&quot;</span><span class="p">,</span><span class="s">&quot;er&quot;</span><span class="p">)</span></code></pre></div>

<h3>可变参数函数</h3>

<p>可变参数函数是指函数可以接收不固定个参数。在参数类型后面添加 <strong>…</strong> 来标记这个参数为可变参数。我们可以在函数中像访问数组一样访问可变参数。</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">func</span> <span class="n">foo</span><span class="p">(</span><span class="nl">names</span><span class="p">:</span><span class="n">String</span><span class="p">...)</span> <span class="o">-&gt;</span><span class="p">()</span> 
   <span class="k">for</span> <span class="n">name</span> <span class="k">in</span> <span class="n">names</span> 
 <span class="n">println</span><span class="p">(</span><span class="s">&quot;(name)&quot;</span><span class="p">)</span>
   <span class="p">}</span>
 <span class="p">}</span>
<span class="n">func</span> <span class="n">foo</span><span class="p">(</span><span class="s">&quot;zhao&quot;</span><span class="p">,</span><span class="s">&quot;zhang&quot;</span><span class="p">,</span><span class="s">&quot;wang&quot;</span><span class="p">)</span></code></pre></div>

<h3>In-out 参数函数</h3>

<p>传入函数的参数值只能在函数域内改变。参数传递是值传递，也就是说我们在函数内部修改了一个参数的值，在函数结束后，函数外部访问到的参数值还是传入函数之前的值，它并没有随着函数内的修改而改变。在<strong>Objective-C</strong> 我们通过指针来保存函数内修改过的值以供函数结束后外部访问。常见的例子就是 <strong>NSError</strong> 的使用。
在<strong>Swift</strong> 中我们也可以做类似的操作。我们需要** inout** 关键字来标记要修改的参数。</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">func</span> <span class="n">swapTwoInts</span><span class="p">(</span><span class="k">inout</span> <span class="nl">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">inout</span> <span class="nl">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>  
    <span class="n">let</span> <span class="n">temporaryA</span> <span class="o">=</span> <span class="n">a</span>
 <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> 
 <span class="n">b</span> <span class="o">=</span> <span class="n">temporaryA</span>
<span class="p">}</span>
<span class="n">var</span> <span class="n">someInt</span> <span class="o">=</span> <span class="mi">3</span> 
<span class="n">var</span> <span class="n">anotherInt</span> <span class="o">=</span> <span class="mi">107</span> 
<span class="n">swapTwoInts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">someInt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">anotherInt</span><span class="p">)</span></code></pre></div>

<h2>闭包 { ()-&gt;() in }</h2>

<h3>定义一个闭包</h3>

<p>闭包是一个使用花括号**** 包围起来，并且使用函数类型<strong>()-&gt;()</strong>来定义的代码模块。<strong>-&gt;</strong>符号分割了输入参数和返回值类型。在关键字 <strong>in</strong> 来区分闭包的头和闭包函数体。</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">returnType</span> <span class="k">in</span> 
<span class="n">statements</span>
<span class="p">}</span></code></pre></div>

<p>一个数组的<strong>map</strong>闭包的例子 </p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;zhao&quot;</span><span class="p">,</span><span class="s">&quot;wang&quot;</span><span class="p">,</span><span class="s">&quot;Li&quot;</span><span class="p">]</span> 
<span class="n">names</span><span class="p">.</span><span class="n">map</span><span class="p">(</span>
  <span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="n">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="k">in</span> 
<span class="s">&quot;(name) has been map !&quot;</span>
<span class="p">})</span></code></pre></div>

<h3>已知参数类型的闭包</h3>

<p><strong>map</strong>的闭包是作为函数参数传入的，所以 <strong>Swift</strong> 是可以做类型推断的，这样的话我们就不需要在闭包中在描述闭包的函数类型，也就是我们可以省略 <strong>(String) -&gt; (String)</strong> 部分，来简写闭包表达式</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="n">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;zhao&quot;</span><span class="p">,</span><span class="s">&quot;wang&quot;</span><span class="p">,</span><span class="s">&quot;Li&quot;</span><span class="p">]</span> 
<span class="n">names</span><span class="p">.</span><span class="n">map</span><span class="p">(</span>
  <span class="n">name</span> <span class="k">in</span> 
<span class="s">&quot;(name) has been map !&quot;</span>
<span class="p">})</span></code></pre></div>

<h3>如果闭包有返回值我们也可以简写省略掉return。</h3>

<p>例如</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;zhao&quot;</span><span class="p">,</span><span class="s">&quot;wang&quot;</span><span class="p">,</span><span class="s">&quot;Li&quot;</span><span class="p">]</span> 
<span class="k">let</span> <span class="n">orderNames</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">names</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span><span class="p">)</span></code></pre></div>

<h3>闭包参数名简写</h3>

<p><strong>Swift</strong> 为内联函数提供了参数名称简写功能，您可以直接通过 $0,$1,$2等名字来引用的闭包的参数的值。</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;zhao&quot;</span><span class="p">,</span><span class="s">&quot;wang&quot;</span><span class="p">,</span><span class="s">&quot;Li&quot;</span><span class="p">]</span> 
<span class="n">names</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="s">&quot;($0) has been map !&quot;</span><span class="p">)</span>
<span class="n">sort</span><span class="p">(</span><span class="n">names</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="err">$</span><span class="mi">1</span><span class="p">)</span></code></pre></div>

<p>如果闭包是函数的最后一个参数，我们可以省略掉圆括号</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">names</span><span class="p">.</span><span class="n">map</span><span class="s">&quot;($0) has been map !&quot;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">names</span><span class="p">)</span><span class="err">$</span><span class="mi">0</span> <span class="o">&gt;</span> <span class="err">$</span><span class="mi">1</span></code></pre></div>

<p>对于排序函数 <strong>sort()</strong> 来说作为参数的闭包表达式只进行了两个值的比较，比较是通过操作符 <strong>&gt;</strong>来进行的。在<strong>Swift</strong>中可以进行操作符重载，我们会发现在<strong>String</strong> 中定义了<strong>&gt;</strong>的函数实现，也就是 <strong>&gt;</strong> 本身就是一个函数 ，它接收两个<strong>String</strong> 类型的参数 并返回一个<strong>Bool</strong>类型的值。这和 <strong>Sort</strong> 函数的第二个参数的类型是一致的。所以，我们还可以进一步简写 <strong>Sort()</strong></p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">sort</span><span class="p">(</span><span class="n">names</span><span class="p">,</span><span class="o">&gt;</span><span class="p">)</span></code></pre></div>

<h2>闭包跟函数是引用类型</h2>

<p>无论您将函数/闭包赋值给一个常量还是变量，您实际上都是将常量/变量的值设置为对应函数/闭包的引用。这也意味着如果您将闭包赋值给了两个不同的常量/变量，两个值都会指向同一个闭包：</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/03/30/%E6%97%A7%E8%83%B6%E7%89%87%E6%95%88%E6%9E%9C/">
        Core Image 旧胶片效果
      </a>
    </h1>

    <span class="post-date">30 Mar 2014</span>

     <p>下面是实现一个带燥点的旧胶片效果的处理流程</p>

<p><img src="http://sipdar.github.io/image/2014/03/30/1.png" alt="image"></p>

<ul>
<li>首先用 <strong>CISepiaTone</strong> 生成单色旧胶片的图像</li>
<li>然后生成一张白色燥点的遮罩图片</li>
<li>然后生成一张黑色划痕燥点的遮罩图片，来体现胶片磨损的效果</li>
<li>最后把三张图片合成在一起</li>
</ul>

<h2>首先来单色照片</h2>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="bp">CIFilter</span> <span class="o">*</span><span class="n">sepiaToneFilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CISepiaTone&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">sepiaToneFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">myImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span></code></pre></div>

<p><img src="http://sipdar.github.io/image/2014/03/30/2.png" alt="image"></p>

<h2>生成白色燥点遮罩然后跟单色的照片合成在一起</h2>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="bp">CIFilter</span> <span class="o">*</span><span class="n">randomFilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIRandomGenerator&quot;</span><span class="p">];</span>
<span class="bp">CIFilter</span> <span class="o">*</span><span class="n">colorFilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIColorMatrix&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">randomFilter</span><span class="p">.</span><span class="n">outputImage</span>    <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="bp">CIVector</span> <span class="o">*</span><span class="n">vector</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mi">1</span> <span class="nl">Z</span><span class="p">:</span><span class="mi">0</span> <span class="nl">W</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">vector</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputRVector&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">vector</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputGVector&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">vector</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputBVector&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Z</span><span class="p">:</span><span class="mi">0</span> <span class="nl">W</span><span class="p">:</span><span class="mf">0.1</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputAVector&quot;</span><span class="p">];</span>
<span class="bp">CIFilter</span> <span class="o">*</span><span class="n">compositingFilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIAdditionCompositing&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">compositingFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">colorFilter</span><span class="p">.</span><span class="n">outputImage</span>   <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="p">[</span><span class="n">compositingFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">sepiaToneFilter</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputBackgroundImageKey</span><span class="p">];</span></code></pre></div>

<p><img src="http://sipdar.github.io/image/2014/03/30/3.png" alt="image"></p>

<h2>生成黑色划痕遮罩 然后在合成在一起</h2>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="bp">CIImage</span> <span class="o">*</span><span class="n">maskImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomFilter</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">imageByApplyingTransform</span><span class="p">:</span><span class="n">CGAffineTransformMakeScale</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">45</span><span class="p">)];</span>
<span class="bp">CIFilter</span> <span class="o">*</span><span class="n">colorFilter2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIColorMatrix&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter2</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">maskImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="bp">CIVector</span> <span class="o">*</span><span class="n">vector2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Z</span><span class="p">:</span><span class="mi">0</span> <span class="nl">W</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter2</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">6</span> <span class="nl">Y</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Z</span><span class="p">:</span><span class="mi">0</span> <span class="nl">W</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputRVector&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter2</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">vector2</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputGVector&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter2</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">vector2</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputBVector&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter2</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">vector2</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputAVector&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">colorFilter2</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mi">1</span> <span class="nl">Z</span><span class="p">:</span><span class="mi">1</span> <span class="nl">W</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputBiasVector&quot;</span><span class="p">];</span>
<span class="bp">CIFilter</span> <span class="o">*</span><span class="n">blackFilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIMinimumComponent&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">blackFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">colorFilter2</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="bp">CIFilter</span> <span class="o">*</span><span class="n">compositingFilter2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIMultiplyCompositing&quot;</span><span class="p">];</span>
<span class="p">[</span><span class="n">compositingFilter2</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">blackFilter</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="p">[</span><span class="n">compositingFilter2</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">compositingFilter</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputBackgroundImageKey</span><span class="p">];</span></code></pre></div>

<p><img src="http://sipdar.github.io/image/2014/03/30/4.png" alt="image"></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/03/29/%E7%A7%BB%E8%BD%B4%E6%95%88%E6%9E%9C%E5%92%8C%E6%B8%90%E5%8F%98/">
        Core Image 移轴效果和渐变
      </a>
    </h1>

    <span class="post-date">29 Mar 2014</span>

     <p>围绕着脸部周围添加一个白色阴影渐变</p>

<ul>
<li>找到图像中的人脸</li>
<li>在CIRadialGradient上以人脸为中心，创建一个遮罩图片</li>
<li>将这遮罩图片与原始图片混合</li>
</ul>

<p><img src="http://sipdar.github.io/image/2014/03/29/1.png" alt="image"></p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="bp">CIContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIContext</span> <span class="nl">contextWithOptions</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="lineno"> 2</span> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">baby</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;baby.jpg&quot;</span><span class="p">];</span>
<span class="lineno"> 3</span> <span class="bp">CIImage</span> <span class="o">*</span><span class="n">myImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIImage</span> <span class="nl">imageWithCGImage</span><span class="p">:</span><span class="n">baby</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">];</span>
<span class="lineno"> 4</span> <span class="bp">CIDetector</span> <span class="o">*</span><span class="n">detector</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIDetector</span> <span class="nl">detectorOfType</span><span class="p">:</span><span class="n">CIDetectorTypeFace</span> <span class="nl">context</span><span class="p">:</span><span class="n">context</span> <span class="nl">options</span><span class="p">:</span><span class="l">@{</span><span class="nl">CIDetectorAccuracy</span><span class="p">:</span><span class="n">CIDetectorAccuracyHigh</span><span class="l">}</span><span class="p">];</span>
<span class="lineno"> 5</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">detector</span> <span class="nl">featuresInImage</span><span class="p">:</span><span class="n">myImage</span><span class="p">];</span>
<span class="lineno"> 6</span> <span class="bp">CIFaceFeature</span> <span class="o">*</span><span class="n">faceFeature</span> <span class="o">=</span> <span class="p">[</span><span class="n">features</span> <span class="n">firstObject</span><span class="p">];</span>
<span class="lineno"> 7</span> <span class="n">CGFloat</span> <span class="n">centerX</span> <span class="o">=</span> <span class="n">faceFeature</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">faceFeature</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="lineno"> 8</span> <span class="n">CGFloat</span> <span class="n">centerY</span> <span class="o">=</span> <span class="n">faceFeature</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">faceFeature</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="lineno"> 9</span> <span class="n">CGFloat</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">faceFeature</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span><span class="n">faceFeature</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.5</span><span class="p">;</span>
<span class="lineno">10</span> <span class="bp">CIFilter</span> <span class="o">*</span><span class="n">radialGradient</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIRadialGradient&quot;</span><span class="nl">keysAndValues</span><span class="p">:</span>
<span class="lineno">11</span>                          <span class="s">@&quot;inputRadius0&quot;</span><span class="p">,</span> <span class="l">@(</span><span class="n">baby</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="l">)</span><span class="p">,</span>
<span class="lineno">12</span>                          <span class="s">@&quot;inputRadius1&quot;</span><span class="p">,</span> <span class="l">@(</span><span class="n">radius</span> <span class="o">+</span> <span class="mf">10.0f</span><span class="l">)</span><span class="p">,</span>
<span class="lineno">13</span>                          <span class="s">@&quot;inputColor0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">CIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">green</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">blue</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mf">1.0</span><span class="p">],</span>
<span class="lineno">14</span>                          <span class="s">@&quot;inputColor1&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">CIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">green</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">blue</span><span class="p">:</span><span class="mf">1.0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mf">0.0</span><span class="p">],</span>
<span class="lineno">15</span>                          <span class="n">kCIInputCenterKey</span><span class="p">,</span> <span class="p">[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="n">centerX</span> <span class="nl">Y</span><span class="p">:</span><span class="n">centerY</span><span class="p">],</span><span class="nb">nil</span><span class="p">];</span>
<span class="lineno">16</span> <span class="bp">CIFilter</span> <span class="o">*</span><span class="n">compositing</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CISourceOverCompositing&quot;</span> <span class="nl">keysAndValues</span><span class="p">:</span>
<span class="lineno">17</span>                          <span class="n">kCIInputImageKey</span><span class="p">,</span><span class="n">radialGradient</span><span class="p">.</span><span class="n">outputImage</span><span class="p">,</span>
<span class="lineno">18</span>                          <span class="n">kCIInputBackgroundImageKey</span><span class="p">,</span><span class="n">myImage</span><span class="p">,</span><span class="nb">nil</span><span class="p">];</span>
<span class="lineno">19</span> <span class="n">CGImageRef</span> <span class="n">cgImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">context</span> <span class="nl">createCGImage</span><span class="p">:</span><span class="n">compositing</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">fromRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">baby</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">baby</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)];</span>
<span class="lineno">20</span> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">maskImage2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithCGImage</span><span class="p">:</span><span class="n">cgImage</span><span class="p">];</span></code></pre></div>

<p><img src="http://sipdar.github.io/image/2014/03/29/2.png" alt="image"></p>

<h2>移轴效果的实现</h2>

<ul>
<li>实现移轴效果首先要生成一张模糊的图像。</li>
<li>然后生成两个线性渐变透明的图像，把它们拼在一起生成一张遮罩图像。</li>
<li>将原始图像模糊图像和遮罩图像混合在一起。</li>
</ul>

<p><img src="http://sipdar.github.io/image/2014/03/29/3.png" alt="image"></p>

<h3>模糊的图像使用<strong>CIGaussianBlur</strong>生成</h3>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="bp">CIContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIContext</span> <span class="nl">contextWithOptions</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="lineno">2</span> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">baby</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;baby.jpg&quot;</span><span class="p">];</span>
<span class="lineno">3</span> <span class="bp">CIImage</span> <span class="o">*</span><span class="n">myImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIImage</span> <span class="nl">imageWithCGImage</span><span class="p">:</span><span class="n">baby</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">];</span>
<span class="lineno">4</span> <span class="bp">CIFilter</span> <span class="o">*</span><span class="n">filter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIGaussianBlur&quot;</span><span class="p">];</span>
<span class="lineno">5</span> <span class="p">[</span><span class="n">filter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">myImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="lineno">6</span> <span class="p">[</span><span class="n">filter</span> <span class="nl">setValue</span><span class="p">:</span><span class="mi">@20</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputRadiusKey</span><span class="p">];</span></code></pre></div>

<p><img src="http://sipdar.github.io/image/2014/03/29/4.png" alt="image"></p>

<h3>两个线性渐变的图像使用 <strong>CILinearGradient</strong></h3>

<p>从一个单色（如绿色或灰色）创建一个线性渐变，一幅从上倒下变化，另一幅从下到上渐变。然后把它们两个合成一张图像</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno"> 1</span> <span class="bp">CIFilter</span> <span class="o">*</span><span class="n">gradientfilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CILinearGradient&quot;</span><span class="p">];</span>
<span class="lineno"> 2</span> <span class="p">[</span><span class="n">gradientfilter</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mf">0.75</span><span class="o">*</span><span class="n">baby</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">]</span>    <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputPoint0&quot;</span><span class="p">];</span>
<span class="lineno"> 3</span> <span class="p">[</span><span class="n">gradientfilter</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mi">0</span> <span class="nl">green</span><span class="p">:</span><span class="mi">1</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputColor0&quot;</span><span class="p">];</span>
<span class="lineno"> 4</span> <span class="p">[</span><span class="n">gradientfilter</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mf">0.5</span> <span class="o">*</span><span class="n">baby</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputPoint1&quot;</span><span class="p">];</span>
<span class="lineno"> 5</span> <span class="p">[</span><span class="n">gradientfilter</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mi">0</span> <span class="nl">green</span><span class="p">:</span><span class="mi">1</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputColor1&quot;</span><span class="p">];</span>
<span class="lineno"> 6</span> 
<span class="lineno"> 7</span> <span class="bp">CIFilter</span> <span class="o">*</span><span class="n">gradientfilter2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CILinearGradient&quot;</span><span class="p">];</span>
<span class="lineno"> 8</span> <span class="p">[</span><span class="n">gradientfilter2</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mf">0.25</span><span class="o">*</span><span class="n">baby</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">]</span>   <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputPoint0&quot;</span><span class="p">];</span>
<span class="lineno"> 9</span> <span class="p">[</span><span class="n">gradientfilter2</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mi">0</span> <span class="nl">green</span><span class="p">:</span><span class="mi">1</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputColor0&quot;</span><span class="p">];</span>
<span class="lineno">10</span> <span class="p">[</span><span class="n">gradientfilter2</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIVector</span> <span class="nl">vectorWithX</span><span class="p">:</span><span class="mi">0</span> <span class="nl">Y</span><span class="p">:</span><span class="mf">0.5</span> <span class="o">*</span><span class="n">baby</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputPoint1&quot;</span><span class="p">];</span>
<span class="lineno">11</span> <span class="p">[</span><span class="n">gradientfilter2</span> <span class="nl">setValue</span><span class="p">:[</span><span class="bp">CIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mi">0</span> <span class="nl">green</span><span class="p">:</span><span class="mi">1</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;inputColor1&quot;</span><span class="p">];</span>
<span class="lineno">12</span> 
<span class="lineno">13</span> <span class="bp">CIFilter</span> <span class="o">*</span><span class="n">compositingFilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIAdditionCompositing&quot;</span><span class="p">];</span>
<span class="lineno">14</span> <span class="p">[</span><span class="n">compositingFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">gradientfilter</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="lineno">15</span> <span class="p">[</span><span class="n">compositingFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">gradientfilter2</span><span class="p">.</span><span class="n">outputImage</span>    <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputBackgroundImageKey</span><span class="p">];</span></code></pre></div>

<p><img src="http://sipdar.github.io/image/2014/03/29/5.png" alt="image"></p>

<p>然后将模糊图像 原图 跟遮罩图像合成在一起。移轴效果比较合适处理建筑物照片人像效果不太好。</p>

<div class="highlight"><pre><code class="language-objc" data-lang="objc"><span class="lineno">1</span> <span class="bp">CIFilter</span> <span class="o">*</span><span class="n">blendFilter</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CIFilter</span> <span class="nl">filterWithName</span><span class="p">:</span><span class="s">@&quot;CIBlendWithMask&quot;</span><span class="p">];</span>
<span class="lineno">2</span> <span class="p">[</span><span class="n">blendFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">blurFilter</span><span class="p">.</span><span class="n">outputImage</span>    <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
<span class="lineno">3</span> <span class="p">[</span><span class="n">blendFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">myImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputBackgroundImageKey</span><span class="p">];</span>
<span class="lineno">4</span> <span class="p">[</span><span class="n">blendFilter</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">compositingFilter</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">kCIInputMaskImageKey</span><span class="p">];</span></code></pre></div>

<p><img src="http://sipdar.github.io/image/2014/03/29/6.png" alt="image"></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/03/27/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/">
        Core Image 人脸检测
      </a>
    </h1>

    <span class="post-date">27 Mar 2014</span>

     <p><strong>Core Image</strong>可以对图像进行分析，并找到图片中人脸的位置。<strong>Core Image</strong>检测出人脸后，可以提供面部特性，比如眼睛和嘴的位置。它还可以跟踪视频中人脸的位置。</p>

<p><img src="http://sipdar.github.io/image/2014/03/27/1.png" alt="image"></p>

<p>下面我们看看如何实现人脸检测。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIImage *baby = [UIImage imageNamed:@&quot;1.jpg&quot;];
CGFloat scale = 320.0/baby.size.width;
CIImage *myimage = [CIImage imageWithCGImage:baby.CGImage];
CIContext *context = [CIContext contextWithOptions:nil];
CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeFace context:context options:@{CIDetectorAccuracy:CIDetectorAccuracyHigh}];
NSArray *features = [detector featuresInImage:myimage];
for (CIFaceFeature *faceFeature in features){
    CGRect bounds = faceFeature.bounds;
    bounds.origin.x *= scale;
    bounds.origin.y *= scale;
    bounds.size.width *= scale;
    bounds.size.height *= scale;
    UIView *faceView = [[UIView alloc] initWithFrame:bounds];
    faceView.backgroundColor = [UIColor clearColor];
    faceView.layer.borderWidth = 1;
    faceView.layer.borderColor = [UIColor redColor].CGColor;
    [self.imageView addSubview:faceView];
}
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/27/2.png" alt="image"></p>

<p>此外，我们还可以拿到眼睛跟嘴巴的位置</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">if (faceFeature.hasLeftEyePosition)
    NSLog(@&quot;Left eye %@&quot;,NSStringFromCGPoint(faceFeature.leftEyePosition));
if (faceFeature.hasRightEyePosition)
    NSLog(@&quot;Right eye %@&quot;,NSStringFromCGPoint(faceFeature.rightEyePosition));
if (faceFeature.hasMouthPosition)
    NSLog(@&quot;Mouth %@&quot;, NSStringFromCGPoint(faceFeature.mouthPosition));
</code></pre></div>
<h2>利用<strong>Core Image</strong> 进行脸部打码</h2>

<p><img src="http://sipdar.github.io/image/2014/03/27/4.png" alt="image">
要实现这个效果，分下面几步。</p>

<ul>
<li>首先我们要生成一张像素化的图像。</li>
<li>然后我们找到图像中人脸的位置，生成一张遮罩图片。</li>
<li>然后我们把像素图片和遮罩图片合成一张图片并且使用原图做为背景。</li>
</ul>

<h3>像素图片</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIImage *baby = [UIImage imageNamed:@&quot;1.jpg&quot;];
CIImage *myimage = [CIImage imageWithCGImage:baby.CGImage];
CGFloat scale = MAX(baby.size.width, baby.size.height)/60;
CIImage *pixlImage =[CIFilter filterWithName:@&quot;CIPixellate&quot; keysAndValues:kCIInputImageKey,myimage,kCIInputScaleKey,@(scale),nil].outputImage;
</code></pre></div>
<h3>脸部遮罩图片</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">CIImage *maskImage = nil;
CIContext *context = [CIContext contextWithOptions:nil];
CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeFace context:context options:@{CIDetectorAccuracy:CIDetectorAccuracyHigh}];
NSArray *features = [detector featuresInImage:myimage];

for (CIFaceFeature *faceFeature in features){
    CGFloat centerX = faceFeature.bounds.origin.x + faceFeature.bounds.size.width / 2.0;
    CGFloat centerY = faceFeature.bounds.origin.y + faceFeature.bounds.size.height / 2.0;
    CGFloat radius = MIN(faceFeature.bounds.size.width, faceFeature.bounds.size.height) / 1.5;
    CIFilter *radialGradient = [CIFilter filterWithName:@&quot;CIRadialGradient&quot; keysAndValues:@&quot;inputRadius0&quot;, @(radius),@&quot;inputRadius1&quot;, @(radius + 1.0f),@&quot;inputColor0&quot;, [CIColor colorWithRed:0.0 green:1.0 blue:0.0 alpha:1.0],@&quot;inputColor1&quot;, [CIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:1.0],kCIInputCenterKey, [CIVector vectorWithX:centerX Y:centerY],nil];
    CIImage *circleImage = [radialGradient valueForKey:kCIOutputImageKey];
    if (nil == maskImage)
        maskImage = circleImage;
    else
        maskImage = [[CIFilter filterWithName:@&quot;CISourceOverCompositing&quot; keysAndValues:kCIInputImageKey, circleImage,kCIInputBackgroundImageKey, maskImage,nil] valueForKey:kCIOutputImageKey];
    }
}
</code></pre></div>
<h3>合成最终的图片</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">CIImage *resultImage =[CIFilter filterWithName:@&quot;CIBlendWithMask&quot; keysAndValues:kCIInputImageKey,pixlImage,@&quot;inputMaskImage&quot;,maskImage,@&quot;inputBackgroundImage&quot;,myimage,nil].outputImage;
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/27/3.png" alt="image">    </p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/03/26/CoreImage%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/">
        Core Image 实时渲染
      </a>
    </h1>

    <span class="post-date">26 Mar 2014</span>

     <p>我们在使用 <strong>AVFoundation</strong> 显示视频的时候，也可以使用 Core Image 进行事实渲染。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">#import &lt;UIKit/UIKit.h&gt;
#import &lt;GLKit/GLKit.h&gt;
#import &lt;AVFoundation/AVFoundation.h&gt;
#import &lt;CoreImage/CoreImage.h&gt;
@interface ViewController : GLKViewController &lt;AVCaptureVideoDataOutputSampleBufferDelegate&gt; {
    AVCaptureSession *session;
    CIContext *coreImageContext;
}
@property (strong, nonatomic) EAGLContext *context;
@end

@implementation ViewController
@synthesize context = _context;
- (void)viewDidLoad{
    [super viewDidLoad];
    self.context = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
    GLKView *view = (GLKView *)self.view;
    view.frame = CGRectMake(0, 0, 640, 1136);
    view.context = self.context;
    view.drawableDepthFormat = GLKViewDrawableDepthFormat24;
    coreImageContext = [CIContext contextWithEAGLContext:self.context];

    NSError * error;
    session = [[AVCaptureSession alloc] init];
    [session beginConfiguration];
    [session setSessionPreset:AVCaptureSessionPreset640x480];
    AVCaptureDevice * videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
    AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&amp;error];
    [session addInput:input];

    AVCaptureVideoDataOutput * dataOutput = [[AVCaptureVideoDataOutput alloc] init];
    [dataOutput setAlwaysDiscardsLateVideoFrames:YES]; 
    [dataOutput setVideoSettings:[NSDictionary dictionaryWithObject:[NSNumber numberWithInt:kCVPixelFormatType_32BGRA] forKey:(id)kCVPixelBufferPixelFormatTypeKey]];   
    [dataOutput setSampleBufferDelegate:self queue:dispatch_get_main_queue()];

    [session addOutput:dataOutput];
    [session commitConfiguration];
    NSArray *array = [[session.outputs objectAtIndex:0] connections];
    for (AVCaptureConnection *connection in array){
        connection.videoOrientation = AVCaptureVideoOrientationPortrait;
    }
    [session startRunning];
}

-(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection {
    CVPixelBufferRef pixelBuffer = (CVPixelBufferRef)CMSampleBufferGetImageBuffer(sampleBuffer);
    CIImage *image = [CIImage imageWithCVPixelBuffer:pixelBuffer];
    CGRect rect = [image extent];
    rect.origin.y = 200;
    rect.size.width  =  640;
    rect.size.height  =  (640.0/480.0)*640;
    CIFilter *filter =[CIFilter filterWithName:@&quot;CISepiaTone&quot;];
    [filter setValue:image forKey:kCIInputImageKey];
    [filter setValue:@0.8 forKey:kCIInputIntensityKey];
    image = filter.outputImage;
    [coreImageContext drawImage:image inRect:rect fromRect:[image extent] ];
}
@end
</code></pre></div>
  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>
    </div>

  </body>
</html>
