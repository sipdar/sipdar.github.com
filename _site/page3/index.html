<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Sunny &middot; A iOS tech blog
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0c">

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Sunny
        </a>
      </h1>
      <p class="lead">This is my personal blog Welcome ！<a href="https://twitter.com/sipdar" target="_blank">@sunny</a>.</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="/">Home</a>
      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/about/">About</a>
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive/">Archives</a>
          
        
      
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
      
<!--       <a class="sidebar-nav-item" href="https://github.com/sipdar/archive/v2.1.0.zip">Download</a> -->
      <a class="sidebar-nav-item" href="https://github.com/sipdar">GitHub project</a>
      <a class="sidebar-nav-item" href="mailto:sipdar@163.com">Email</a>
<!--       <span class="sidebar-nav-item">Currently v2.1.0</span> -->

    </nav>

    <p>&copy; 2015. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2014/03/16/Coordinate_space_transformations/">
        Coordinate Space Transformations
      </a>
    </h1>

    <span class="post-date">16 Mar 2014</span>

     <h2>Coordinate Systems</h2>

<p>Quartz 2D和UIKit的坐标系是不同的，Quartz 2D 使用的是笛卡尔坐标系 原点在左下角，
<img src="http://sipdar.github.io/image/2014/03/16/Quartz2DCoordinate.png" alt="image"></p>

<p>UIkit坐标系的原点在左上角。</p>

<p><img src="http://sipdar.github.io/image/2014/03/16/native_coordinate_system.jpg" alt="image"></p>

<p>这个也就可以理解为什么用Quartz 2D画的图形和UIKit的倒过来的。</p>

<p>但是在IOS 3.2及后续的版本中，当UIKit为你的应用程序创建一个<strong>Graphics Context</strong>时，也对<strong>Context</strong>进行了额外的修改以匹配UIKit的约定。</p>

<h2>What is CTM ?</h2>

<p><strong>CTM</strong> = <strong>Current Transformation Matrix</strong></p>

<p>Quartz通过使用当前转换矩阵(current transformation matrix， CTM)将一个独立的坐标系统(user space)映射到输出设备的坐标系统(device space)，<strong>CTM</strong> 通过平移(translation)、旋转(rotation)、缩放(scale)操作将点从一个坐标空间映射到另外一个坐标空间。</p>

<p>我们可以通过CTM来决定对象如何被绘制。例如，为了绘制一个旋转了45度的矩形，我们可以在绘制矩形之前旋转<strong>Graphics Context</strong>的坐标系统。Quartz使用旋转过的坐标系统来将矩形绘制到输出设备中。设备显示在屏幕上的矩形，就是旋转过后的矩形。</p>

<p>我们先来看一个图片绘制的例子,首先是是没做矩阵转换的代码。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIGraphicsBeginImageContextWithOptions(CGSizeMake(320, 320),NO ,[UIScreen mainScreen].scale);
// Perform drawing here
UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 200, 200)];
[[UIColor redColor] setFill];
[path fill];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
self.imageView.image = image;
UIGraphicsEndImageContext();
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/16/CTM_Original.png" alt="image"></p>

<h2>CGContextTranslateCTM</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIGraphicsBeginImageContextWithOptions(CGSizeMake(320, 320),NO ,[UIScreen mainScreen].scale);
// Perform drawing here
CGContextRef context = UIGraphicsGetCurrentContext();
CGContextTranslateCTM(context, 70, 0);
UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(50, 50, 200, 200)];
[[UIColor redColor] setFill];
[path fill];
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
self.imageView.image = image;
UIGraphicsEndImageContext();
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/16/CTM_Translate.png" alt="image"></p>

<h2>CGContextScaleCTM</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGContextScaleCTM(context, 0.5, 1.5);
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/16/CTM_Scale.png" alt="image"></p>

<h2>CGContextRotateCTM</h2>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGContextRotateCTM(context, M_2_PI);
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/16/CTM_Rotate.png" alt="image"></p>

<p>这时候我们发现旋转并没有按照绘制的<strong>Context</strong>中心旋转， 因为旋转是以坐标系的原点为中心来做的，所以我们为了要保持图片的中心位置就要配合 <strong>CGContextTranslateCTM</strong> 一起使用。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGContextTranslateCTM(context,self.imageView.center.x,self.imageView.center.y);
CGContextRotateCTM(context, M_2_PI);
CGContextTranslateCTM(context, -self.imageView.center.x, -self.imageView.center.y);
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/16/CTM_Rotate_withCenter.png" alt="image"></p>

<h2>CGContextConcatCTM</h2>

<p>此外我们还可以通过 *<em>CGAffineTransform *</em>来变幻坐标系 比如我之前写过的仿射变换。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGContextTranslateCTM(context,self.imageView.center.x,self.imageView.center.y);
CGAffineTransform transform = CGAffineTransformIdentity;
transform = CGAffineTransformScale(transform, 0.5, 0.5);
transform = CGAffineTransformTranslate(transform, 0, 100);
transform.c = -0.5;
transform.b = 0;
CGContextConcatCTM(context, transform);
CGContextTranslateCTM(context, -self.imageView.center.x, -self.imageView.center.y);
</code></pre></div>
<p><img src="http://sipdar.github.io/image/2014/03/16/CTM_Transform.png" alt="image"></p>

<h2>CGContextGetCTM</h2>

<p>我们可以通过 <strong>CGContextGetCTM</strong> 在程序运行中取回当前<strong>Context</strong>上使用的转换矩阵。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/12/10/Core_Animation(%E5%85%AB)_CAShapeLayer/">
        Core Animation CAShapeLayer
      </a>
    </h1>

    <span class="post-date">10 Dec 2013</span>

     <h1>CAShapeLayer</h1>

<p>我们在上面曾经用过<strong>CGPath</strong>代替图片来绘制阴影，同样的我们可以使用<strong>CGPath</strong>来绘制各种我们想要的图形，用来代替图片使用。</p>

<p><strong>CAShapeLayer</strong>是 <strong>CALayer</strong>的子类，在绘制的时候它使用的是矢量图形，而不是 <strong>Bitmap Image</strong>，因此效率非常高。在使用的时候 只要我们定义好颜色 线条的宽度，然后用<strong>CGPath</strong>来定义出形状，剩下的 <strong>CAShapeLayer</strong>会自动渲染。当然我们也可以使用 <strong>Core Graphics</strong>在<strong>CALayer</strong>中绘制我们想要的内容，但是有使用 <strong>CAShapeLayer</strong>有它的好处，</p>

<ul>
<li>首先它速度非常快，<strong>CAShaplayer</strong>使用的是硬件加速，比起用 <strong>Core Graphics</strong>画一个图来会快很多</li>
<li>节省内存 它不象<strong>CALayer</strong>那样会创建背景图片，所以无论它有多大，都不会太消耗内存</li>
<li>不会剪切超出自己<strong>bounds</strong>的部分， 但是使用<strong>CALayer</strong>的时候我们就会被<strong>CGPath</strong>剪切掉超出的部分</li>
<li>没有像素画，在做缩放变幻的时候，不会出现像素化的情况。</li>
</ul>

<p>我们看个小栗子 怎么使用 <strong>CASapeLayer</strong></p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIBezierPath *path = [[UIBezierPath alloc] init];
[path moveToPoint:CGPointMake(175, 100)];
[path addArcWithCenter:CGPointMake(150, 100) 
                radius:25 
            startAngle:0 
              endAngle:2*M_PI
             clockwise:YES];

[path moveToPoint:CGPointMake(150, 125)];
[path addLineToPoint:CGPointMake(150, 175)]; 
[path addLineToPoint:CGPointMake(125, 225)];
[path moveToPoint:CGPointMake(150, 175)]; 
[path addLineToPoint:CGPointMake(175, 225)];
[path moveToPoint:CGPointMake(100, 150)];
[path addLineToPoint:CGPointMake(200, 150)];

CAShapeLayer *shapeLayer = [CAShapeLayer layer]; 
shapeLayer.strokeColor =    [UIColor redColor].CGColor; 
shapeLayer.fillColor = [UIColor clearColor].CGColor;
shapeLayer.lineWidth = 5;
shapeLayer.lineJoin = kCALineJoinRound; 
shapeLayer.lineCap = kCALineCapRound;   
shapeLayer.path = path.CGPath;
[self.containerView.layer addSublayer:shapeLayer];
</code></pre></div>
<p><img src="http://sipdar.github.io/image/shaplayer1.png" alt="image">
<strong>lineWidth</strong> 就是线的宽度    </p>

<p><strong>lineCap</strong> 线头的效果</p>

<p><strong>lineJoin</strong> 不同的线相交的地方的效果</p>

<h2>圆角</h2>

<p>我们曾经使用过 <strong>CALayer</strong> 的 <strong>cornerRadius</strong>属性来绘制圆角矩形，我们使用 <strong>CAShaplayer</strong>也可以实现这个效果，但是<strong>CAShaplayer</strong>更好的地方在于它可以定义每个角实现不同的效果。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGRect rect = CGRectMake(50, 50, 150, 150);
UIView *testView = [[UIView alloc] initWithFrame:rect];
testView.backgroundColor = [UIColor redColor];
[self.view addSubview:testView];

CGSize radii = CGSizeMake(20, 20);
UIRectCorner corners = UIRectCornerTopRight |
UIRectCornerBottomRight | UIRectCornerBottomLeft;
//create path
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:testView.bounds
                                            byRoundingCorners:corners 
                                                  cornerRadii:radii];
CAShapeLayer *shapeLayer = [CAShapeLayer layer];
shapeLayer.strokeColor = [UIColor greenColor].CGColor;
shapeLayer.fillColor=[UIColor redColor].CGColor;
shapeLayer.lineWidth = 1;
shapeLayer.lineJoin = kCALineJoinRound;
shapeLayer.lineCap = kCALineCapRound;
shapeLayer.path = path.CGPath;
testView.layer.mask =shapeLayer;
</code></pre></div>
<p><img src="http://sipdar.github.io/image/shaplayer2.png" alt="image"></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/10/20/Core_Animation(%E4%B8%83)_3D_Transform/">
        Core Animation (七)3DTransform
      </a>
    </h1>

    <span class="post-date">20 Oct 2013</span>

     <h1>3D Transform</h1>

<h2>3D Transform</h2>

<p><strong>CGAffineTransform</strong> 属于 <strong>Core Graphics Framework</strong> ,<strong>Core Graphic</strong>是一个绘制2D图形的库。<strong>CGAffineTransform</strong> 只提供 2D 的旋转缩放移动等。我们要想实现 3D矩阵下的旋转缩放就要用到<strong>CATransform3D</strong>。在2D动画中，<strong>point</strong>属性只有 X Y 值，在3D坐标中，多了一个 Z 值。它代表的是当前的Layer距离用户视角的远近，正是这个Z值 使我们可以在3D坐标系中旋转缩放移动。 </p>

<p><strong>CATransform3D</strong> 跟 <strong>CGAffineTransform</strong> 一样也是个矩阵，是一个 4x4 的矩阵结构定义如下。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">struct CATransform3D
{
  CGFloat m11, m12, m13, m14;
  CGFloat m21, m22, m23, m24;
  CGFloat m31, m32, m33, m34;
  CGFloat m41, m42, m43, m44;
};
typedef struct CATransform3D CATransform3D;
</code></pre></div>
<p>3D转换的计算如下。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/transform_basic_math_2x.png" alt="image"></p>

<p>下面是几种常用的3D变换矩阵 跟 <strong>CGAffineTransform</strong> 矩阵非常相似</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/transform_manipulations_2x.png" alt="image"></p>

<p><strong>Core Graphic</strong> 提供了一些列的函数使我们可以方便简单的实现 3D变换。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CATransform3DMakeRotation(angle,x,y,z);
CATransform3DMakeScale(sx,sy,sz);
CATransform3DMakeTranslation(tx,ty,tz);
</code></pre></div>
<p>我们看下面这个例子</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIImage *image = [UIImage imageNamed:@&quot;DragonMedium&quot;];
UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
imageView.backgroundColor = [UIColor greenColor];
imageView.frame = CGRectMake(0, 0 , CGRectGetWidth(imageView.frame),
                             CGRectGetHeight(imageView.frame));
imageView.center = self.view.center;

CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
imageView.layer.transform = transform;
[self.view addSubview:imageView];
</code></pre></div>
<p><img src="http://m1.img.libdd.com/farm5/2013/1020/22/00594CE26CC3572725BEF8911D9A93EBE1B6259EAEAD7_594_856.PNG" alt="image"></p>

<p>好像只是简单的压缩了宽度。并没有出现我们预期的3D 沿 Y轴旋转的效果，这是为什么呢。我们知道，要想在2D平面表现3D效果，无论是拍照，还是绘画都要用到一个叫做透视法的东西，当我们距离一个物体越远的时候，我们看它就越小，在<strong>CATransform3D</strong>有一个值是控制透视效果的，就是 <strong>m34</strong> .默认的情况下 <strong>m34</strong>的值是零，意味着我们是在元素的角度看到UI，我们把上面的代码稍加改造。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CATransform3D transform =   CATransform3DIdentity;
transform.m34 = -1.0 / 500.0;
transform = CATransform3DRotate(transform,M_PI_4, 0, 1, 0);
imageView.layer.transform = transform;
</code></pre></div>
<p><img src="http://m3.img.libdd.com/farm5/2013/1020/22/D23F55284B47C8C51F62F170CAA35113AA8262A12DC96_594_856.PNG" alt="image"></p>

<p>这次看上去就对了。我们将<strong>m34</strong> 的值设为 <strong>-1.0/d</strong> .d 表示的就是虚拟的摄像头跟屏幕的距离，因为摄像头并不是真的存在，这个值通常是靠感觉来调整的，一般来说 500 到 1000 都是不错的值。 可以多尝试几次。</p>

<h2>消失点</h2>

<p>艺术家或者工程师在纸上表现立体图时，常用一种透视法，这种方法源于人们的视觉经验：大小相同的物体，离你较近的看起来比离你较远的大。如当你沿着铁路线去看两条铁轨，沿着公路线去看两边排列整齐的树木时，两条平行的铁轨或两排树木连线交与很远很远的某一点，这点在透视图中叫做消失点。 凡是平行的直线都消失于无穷远处的同一个点，消失于视平线上的点的直线都是水平直线。（<a href="http://baike.baidu.com/view/726134.htm">百度百科</a>）</p>

<p><img src="http://m2.img.libdd.com/farm4/2013/1021/20/CF205F5BC5542C74D828DE5389D87F732919DF3EF7AAB_600_270.PNG" alt="image"></p>

<p>在2D的 <strong>transform</strong> 中我们知道做变换的<strong>Layer</strong>都有一个锚点。在<strong>3D</strong>变换中，消失点就相当于一个锚点。
当我们在3D坐标系中，每次更改<strong>Layer</strong>的位置，同时也就更改消失点的位置。如果我们打算通过调整一个<strong>Layer</strong> 的 <strong>M34</strong> 来显示3D效果，那么 我们应该把先消失点定位在屏幕的中心，然后移动它到相应的位置，使得屏幕上所有的<strong>Layer</strong>可以共享同一个消失点。已达到一个整体的3D效果。</p>

<h2>sublayerTransform</h2>

<p>如果我们有多个<strong>View</strong>或者<strong>Layer</strong>的时候，并且它们每一个都有单独的3D变换，这时候我们有必要使用统一的<strong>M34</strong>的值，来保证它们在屏幕上显示的时候有个共同的消失点。</p>

<p><strong>CALayer</strong>有个属性叫做 <strong>sublayerTransform</strong> 它也是一个 <strong>CATransform3D</strong> ，它只是在变换的时候作用于 <strong>subLayer</strong> 。这意味着我们可以在<strong>superLayer</strong>上设置变换，<strong>subLayer</strong>都将自动继承。消失点会设置在<strong>superLayer</strong>上，也就不必在单独给每一个<strong>subLayer</strong>设置消失点了。
我们看下面这个栗子。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIView *superImageView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 200)];
superImageView.backgroundColor = [UIColor redColor];
superImageView.center = self.view.center;

UIImage *image = [UIImage imageNamed:@&quot;DragonMedium&quot;];
UIImageView *leftimageView = [[UIImageView alloc] initWithImage:image];
UIImageView *rightImageView = [[UIImageView alloc] initWithImage:image];
leftimageView.backgroundColor = [UIColor greenColor];
rightImageView.backgroundColor = [UIColor greenColor];
leftimageView.frame = CGRectMake(0, 25 , 150,150);
rightImageView.frame = CGRectMake(170, 25 ,150,150);

[superImageView addSubview:leftimageView];
[superImageView addSubview:rightImageView];


CATransform3D superTransform = CATransform3DIdentity;
superTransform.m34 = -1.0/500.0;
superImageView.layer.sublayerTransform = superTransform;

CATransform3D transformLeft = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
CATransform3D transformRight = CATransform3DMakeRotation(M_PI_4, 0, -1, 0);
leftimageView.layer.transform = transformLeft;
rightImageView.layer.transform = transformRight;

[self.view addSubview:superImageView];
</code></pre></div>
<p><img src="http://m2.img.libdd.com/farm5/2013/1021/21/39A11261A15AA4267609265CFC081E716C6A92BD91981_771_548.PNG" alt="image"></p>

<h2>镜像</h2>

<p>当我们把上面得例子中得<strong>rightImageView</strong>的<strong>transform</strong> 去掉。<strong>leftImageView</strong>的 弧度参数从<strong>M<em>PI</em>4</strong> 变成 <strong>M_PI</strong> 。发生了什么？</p>

<p><img src="http://m3.img.libdd.com/farm5/2013/1021/22/CC17B94FEFD651EFFC31370D805FB1A3DE08FDBE85BF6_594_856.PNG" alt="image"></p>

<p>我们得到了一个<strong>Layer</strong>的镜像。在3D变幻中有时候这种反面的镜像的计算和绘制是没有必要的，比如在一个不透明的物体做3D变幻的时候。对于背面的东西既然是不可见的也就没必要浪费资源显示。所以 <strong>CALayer</strong>有个属性叫做 <strong>doubleSided</strong> 可以关掉。</p>

<h2>当一个Layer和它所包含的Layer做相反的变换会发生什么呢？</h2>

<p>我们现在试着把<strong>superLayer</strong>向右旋转 45度，把<strong>subLayer</strong>向左旋转45度。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIView *superImageView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
superImageView.backgroundColor = [UIColor redColor];

UIImage *image = [UIImage imageNamed:@&quot;DragonMedium&quot;];
UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
imageView.backgroundColor = [UIColor greenColor];
imageView.frame = CGRectMake(0,0 ,150,150);
imageView.center = superImageView.center;

[superImageView addSubview:imageView];
superImageView.center = self.view.center;

CATransform3D transformLeft = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
CATransform3D transformRight = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
superImageView.layer.transform = transformLeft;
imageView.layer.transform = transformRight;

[self.view addSubview:superImageView];
</code></pre></div>
<p><img src="http://m1.img.libdd.com/farm4/2013/1021/22/7D268867F512EF7FBC26294BA406F7C78CC528DBF8165_594_856.PNG" alt="image"></p>

<p>我们在试试3D显示。将上面栗子中的3D transform 修改成下面这样</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CATransform3D transformLeft = CATransform3DIdentity;
transformLeft.m34 = -1.0 / 500.0;
transformLeft = CATransform3DRotate(transformLeft, M_PI_4, 0, 1, 0);

CATransform3D transformRight = CATransform3DIdentity;
transformRight.m34 = -1.0 / 500.0;
transformRight = CATransform3DRotate(transformRight, -M_PI_4, 0, 1, 0);

superImageView.layer.transform = transformLeft;
imageView.layer.transform = transformRight;
</code></pre></div>
<p><img src="http://m3.img.libdd.com/farm4/2013/1021/22/84AA693C9690E7E26F750C11EA1C1718866B603CA9410_594_856.PNG" alt="image">
我们发现绿色部分的变换比以前例子中的效果来变形的非常厉害，这是因为在做3D变换的时候每个<strong>Layer</strong>的坐标系都是以<strong>superLayer</strong>为参照的。也就是说 红色<strong>Layer</strong>跟绿色<strong>Layer</strong>并不在同一个参照系里。当我们要用 <strong>Core Animation</strong>创建一些复杂的3D效果的时候，要注意这点。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/10/19/Core_Animation(%E5%85%AD)_AffineTransform/">
        Core Animation (六)CGAffineTransform
      </a>
    </h1>

    <span class="post-date">19 Oct 2013</span>

     <h1>变换</h1>

<p>图层一旦创建,你就可以通过矩阵变换来改变一个图层的几何形状。<strong>CGAffineTransform</strong> ,用于 图层的旋转,缩放,位移，还有 <strong>CATransform3D</strong> 它可以把二维的平面转换到三维矩阵中。</p>

<h2>Affine Transforms</h2>

<p><strong>UIView</strong>  有个属性是 <strong>transform</strong>,<strong>transform</strong> 的类型就是 <strong>CGAffineTransform</strong> 通过它我们可以对<strong>UIView</strong>做一些二维的旋转缩放之类的操作。<strong>CGAffineTransform</strong> 的定义如下</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">struct CGAffineTransform {
      CGFloat a, b, c, d;
      CGFloat tx, ty;
};
</code></pre></div>
<p>它其实表示的是一个矩阵       </p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation01.gif" alt="image"></p>

<p>因为最后一列总是是(0,0,1)，所以有用的信息就是前面两列，对一个view进行仿射变化就相当于对view上的每个点做一个乘法，结果就是</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation02.gif" alt="image"></p>

<p>下面举例说明几个转换运算的数学实现，x y 是原先点的坐标，下面是矩阵转换的计算公式</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation03.gif" alt="image"></p>

<h3>恒等矩阵</h3>

<p>恒等矩阵就是输入什么坐标，出来什么坐标，没有转换</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation04.gif" alt="image"></p>

<p>计算的结果如下，计算之前的x y 跟计算之后的 x‘ y’ 是相等的。</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation05.gif" alt="image"></p>

<h3>平移矩阵</h3>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation06.gif" alt="image"></p>

<p>通过平移矩阵的计算公式如下</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation07.gif" alt="image"></p>

<h3>缩放矩阵</h3>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation08.gif" alt="image"></p>

<p>缩放矩阵的计算公式</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation09.gif" alt="image"></p>

<h3>旋转矩阵</h3>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation10.gif" alt="image"></p>

<p>旋转矩阵的计算公式</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation11.gif" alt="image"></p>

<h3>旋转加平移矩阵</h3>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation12.gif" alt="image"></p>

<p>下面就是组合起来的计算公式</p>

<p><img src="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/equation13.gif" alt="image"></p>

<p>AffineTransform类描述了一种二维仿射变换的功能，它是一种二维坐标到二维坐标之间的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（是指保二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变，另特别注意向量间夹角可能会发生变化。）仿射变换可以通过一系列的原子变换的复合来实现，包括：平移（Translation）、缩放（Scale）、翻转（Flip）、旋转（Rotation）和错切（Shear）</p>

<p><img src="http://m1.img.libdd.com/farm5/2013/1019/20/8B45FAAB1B7FF35E7BBDFB6BF60F0B1CCE48596C04FAE_482_342.PNG" alt="image"></p>

<h2>创建一个 <strong>CGAffineTransform</strong></h2>

<p>看了上面的的矩阵和计算有点叫人挠头。 不过 <strong>Core Graphics</strong>为了方便开发者，提供了好多内建的函数，可以使我们不必学习复杂的数学知识，就可以实现上面的操作。
下面的方法都可以创建 <strong>CGAffineTransform</strong></p>

<p>函数| 操作 
------------ | -------------
CGAffineTransformMakeTranslation | 新的平移矩阵要移动到距离远点的位置<br>
CGAffineTransformMakeRotation | 构建一个新的旋转矩阵 参数是旋转的弧度。
CGAffineTransformMakeScale | 构建一个新的缩放矩阵指定多少拉伸或收缩坐标x和y值。</p>

<p>我们看下面这个例子，它把LLVM的logo 旋转了 45°：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIImage *image = [UIImage imageNamed:@&quot;DragonMedium&quot;];
UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
imageView.frame = CGRectMake(0, 0 , CGRectGetWidth(imageView.frame),
                                     CGRectGetHeight(imageView.frame));
imageView.center = self.view.center;
imageView.transform = CGAffineTransformMakeRotation(M_PI_4);
[self.view addSubview:imageView];
</code></pre></div>
<p><img src="http://m3.img.libdd.com/farm4/2013/1019/21/D78163CE65A5BDE31AFB5899ABBECB2C63DFCF8CA2CCB_594_856.PNG" alt="image"></p>

<p>我们在旋转ImageView的时候 传给 <strong>CGAffineTransformMakeRotation</strong> 的参数是一个宏定义 <strong>M<em>PI</em>4</strong>,并不是 45°。旋转的单位采用弧度(radians),而不是角度(degress)。以下两个函数,你可以在 弧度和角度之间切换。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGFloat DegreesToRadians(CGFloat degrees) {return degrees * M_PI / 180;};
￼CGFloat RadiansToDegrees(CGFloat radians) {return radians * 180 / M_PI;};
</code></pre></div>
<p>弧度通常指定使用的数学常数π（圆周率）的倍数。 π弧度等于180度，所以π除以4是相当于45度。
C 的<strong>math</strong>库，方便地提供常数π的公倍数，M<em>PI</em>4是常数，表示π除以4。如果你想使用弧度时候，你可以直接使用这些宏。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">#define M_E         2.71828182845904523536028747135266250   /* e              */
#define M_LOG2E     1.44269504088896340735992468100189214   /* log2(e)        */
#define M_LOG10E    0.434294481903251827651128918916605082  /* log10(e)       */
#define M_LN2       0.693147180559945309417232121458176568  /* loge(2)        */
#define M_LN10      2.30258509299404568401799145468436421   /* loge(10)       */
#define M_PI        3.14159265358979323846264338327950288   /* pi             */
#define M_PI_2      1.57079632679489661923132169163975144   /* pi/2           */
#define M_PI_4      0.785398163397448309615660845819875721  /* pi/4           */
#define M_1_PI      0.318309886183790671537767526745028724  /* 1/pi           */
#define M_2_PI      0.636619772367581343075535053490057448  /* 2/pi           */
#define M_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi)     */
#define M_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2)        */
#define M_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2)      */
</code></pre></div>
<h2>组合Transforms</h2>

<p><strong>Core Graphics</strong> 还提供了另外一系列的函数，使开发者可以方便的组合 <strong>Transforms</strong></p>

<p>例如</p>

<p>函数| 操作 
------------ | -------------
GAffineTransformRotate(CGAffineTransform t, CGFloat angle)  | 原始的基础上加上偏移
CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) | 加上缩放
CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty) | 加上旋转</p>

<p>当我们操作 <strong>Transforms</strong> 的时候，我们经常会创建一个初始的什么也不做的<strong>Transform</strong>，就像 <strong>point</strong> 的 <strong>zero</strong> 或者 <strong>nil</strong>。在矩阵的世界中，恒等矩阵就是干这个用的。 <strong>Core Graphics</strong> 为我们提供了 </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGAffineTransformIdentity
</code></pre></div>
<p>当我们想组合两个已经存在的 <strong>transform</strong>的时候，我们可以使用</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
</code></pre></div>
<p>下面的代码使LLVM的logo 缩小了50% 旋转了45°，并且向下移动了100的位置。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIImage *image = [UIImage imageNamed:@&quot;DragonMedium&quot;];
UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
imageView.frame = CGRectMake(0, 0 , CGRectGetWidth(imageView.frame), 
                                    CGRectGetHeight(imageView.frame));
imageView.center = self.view.center;

CGAffineTransform transform = CGAffineTransformIdentity;
transform = CGAffineTransformScale(transform, 0.5, 0.5);
transform = CGAffineTransformTranslate(transform, 0, 100);

imageView.transform = CGAffineTransformRotate(transform, M_PI_4);
[self.view addSubview:imageView];
</code></pre></div>
<p><img src="http://m2.img.libdd.com/farm5/2013/1019/22/CE867462973B6617719D875B002DCE2EFB1FFE54D45AB_594_856.PNG" alt="image">      </p>

<h2>Shear Transform</h2>

<p><strong>Shear Transform</strong> 是第四种 <strong>Affine Transform</strong> （我也不知道该怎么翻译这个 Shear Transform）。和旋转 缩放 移动 不同的是 <strong>Core Graphics</strong>并没有提供现成的函数来做 <strong>Shear Transform</strong>,不过我们可以自己来实现他。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)
{
    CGAffineTransform transform = CGAffineTransformIdentity;
    transform.c = -x;
    transform.b = y;
    return transform;
}
</code></pre></div>
<p>下面给imageview 添加上 transform</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIImage *image = [UIImage imageNamed:@&quot;DragonMedium&quot;];
UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
imageView.backgroundColor = [UIColor greenColor];
imageView.frame = CGRectMake(0, 0 , CGRectGetWidth(imageView.frame), 
                                    CGRectGetHeight(imageView.frame));
imageView.center = self.view.center;
imageView.transform = CGAffineTransformMakeShear(0.6,0);

[self.view addSubview:imageView];
</code></pre></div>
<p>效果如下</p>

<p><img src="http://m1.img.libdd.com/farm4/2013/1019/22/433CC9E800E500602AB99C94F72ACC8FA3529787B5BEE_594_856.PNG" alt="image">  </p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/10/17/Core_Animation(%E4%BA%94)_Layer_Masking/">
        Core Animation (五)Layer Masking
      </a>
    </h1>

    <span class="post-date">17 Oct 2013</span>

     <h1>Layer Masking (五)</h1>

<h2>Layer Masking</h2>

<p>当使用 <strong>masksToBounds</strong> 的时候，它会沿着layer的边框进行裁切超出的部分。包括使用 <strong>cornerRadius</strong>也是这样，裁出一个圆角矩形来。但是有时候我们想绘制的并不是一个矩形，或者一个圆角矩形，比如我现在想以五角星的形状来显示一个image对象，在比如我想在滚动一个显示文本的View的时候可以叫他优雅的在屏幕边缘淡出，而不是笔直的切割显示区域的边缘。
有两种方法可以实现，一种就是用 带 <strong>alpha</strong> 透明的<strong>PNG</strong>图片盖在要显示的区域上，当我们在程序中要动态的裁切图片显示区域的时候这个方法可能就不实用了。</p>

<p><strong>CAlayer</strong> 有个<strong>mask</strong>属性， <strong>mask</strong>本身就是一个<strong>CAlayer</strong>，它和其他任何的<strong>Layer</strong>没什么不同。使用<strong>mask layer</strong>的时候，跟其他的<strong>sublayer</strong>没什么区别，不同的是它并像一个普通的<strong>subLayer</strong>那样显示在<strong>superLayer</strong>上 ，它决定了<strong>superLayer</strong>的可显示区域。
<strong>mask Layer</strong>的color 属性就可以忽略了。<strong>mask</strong>会把<strong>superLayer</strong>裁切,只显示符合 <strong>Mask</strong> 大小的部分.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">UIView *viewA = [[UIView alloc] initWithFrame:CGRectMake(100, 80, 100, 100)];
UIView *viewB = [[UIView alloc] initWithFrame:CGRectMake(350, 80, 100, 100)];
UIImage *image = [UIImage imageNamed:@&quot;kangaroo.png&quot;];
UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
imageView.frame = CGRectMake(250, 100 , CGRectGetWidth(imageView.frame), 
                                         CGRectGetHeight(imageView.frame));
viewB.backgroundColor = [UIColor greenColor];
viewA.backgroundColor = [UIColor greenColor];

CALayer *layer = [CALayer layer];

layer.frame = CGRectMake(10, 20, image.size.width, image.size.height);
layer.contents = (id)image.CGImage;
viewB.layer.mask = layer;

[self.view addSubview:imageView];
[self.view addSubview:viewA];
[self.view addSubview:viewB];
</code></pre></div>
<p><img src="http://m3.img.libdd.com/farm5/2013/1018/23/0EEEEA8A23052F8A25B94C45104B54AD29117463794C2_880_532.PNG" alt="image"></p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page4">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page2">Newer</a>
    
  
</div>
    </div>

  </body>
</html>
